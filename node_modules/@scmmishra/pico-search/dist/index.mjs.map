{"version":3,"sources":["../src/algorithms/jaroWinkler.ts","../src/utils.ts","../src/pico.ts"],"sourcesContent":["/**\n * Calculates the Jaro-Winkler similarity between two strings.\n * @param {string} str1 - The first string to compare.\n * @param {string} str2 - The second string to compare.\n * @returns {number} A value between 0 and 1 indicating the similarity between the two strings, where 1 means the strings are identical and 0 means the strings are completely different.\n */\nexport default function jaroWinkler(str1: string, str2: string): number {\n  // Swap strings if str1 is shorter than string 2\n  if (str1.length < str2.length) {\n    const tempString: string = str1;\n    str1 = str2;\n    str2 = tempString;\n  }\n\n  const len1: number = str1.length;\n  let len2: number = str2.length;\n  if (!len2) {\n    return 0.0;\n  }\n\n  const delta: number = Math.max(1, len1 / 2.0) - 1.0;\n\n  // Flags for transpositions\n  const flag: boolean[] = Array(len2).fill(false);\n  const ch1Match: string[] = Array(len1).fill(\"\");\n  // Count number of matching characters\n  let matches = 0;\n  // Check if characters on both string matches\n  for (let i = 0; i < len1; i++) {\n    const ch1: string = str1[i];\n    for (let j = 0; j < len2; j++) {\n      const ch2: string = str2[j];\n      if (j <= i + delta && j + delta >= 1 && ch1 === ch2 && !flag[j]) {\n        flag[j] = true;\n        ch1Match[matches++] = ch1;\n        break;\n      }\n    }\n  }\n\n  if (!matches) {\n    return 0;\n  }\n\n  // Count number of transpositions (shared characters placed in different positions)\n  let transpositions = 0.0;\n  for (let i = 0, j = 0; j < len2; j++) {\n    if (flag[j]) {\n      if (str2[j] !== ch1Match[i]) {\n        transpositions++;\n      }\n      i++;\n    }\n  }\n\n  const mCount: number = matches;\n\n  // Jaro Similarity Formula simj = ( (m / length of s1) + (m / length of s2) + (m - t) / m ) / 3\n  const jaro: number =\n    (mCount / len1 + mCount / len2 + (mCount - transpositions / 2.0) / mCount) /\n    3.0;\n\n  // Length of common prefix between string up to 4 characters\n  let commonPrefix = 0.0;\n  len2 = Math.min(4, len2);\n\n  for (let i = 0; i < len2; i++) {\n    if (str1[i] === str2[i]) {\n      commonPrefix++;\n    }\n  }\n\n  return jaro + commonPrefix * 0.1 * (1.0 - jaro);\n}\n","/**\n * Calculates the weighted average of a set of values.\n * @param {number[]} values - The values to be averaged.\n * @param {number[]} [weights] - The weights to be applied to the values.\n * @returns {number} The weighted average of the values.\n * @throws {Error} If the number of values is not equal to the number of weights.\n */\nexport function weightedAverage(values: number[], weights?: number[]): number {\n  if (weights && values.length !== weights.length) {\n    throw new Error(\n      \"The number of values must be equal to the number of weights\"\n    );\n  }\n\n  const sum = values.reduce((prev, curr, index) => {\n    const weight = weights ? weights[index] : 1;\n    return prev + curr * weight;\n  }, 0);\n\n  const totalWeight = weights\n    ? weights.reduce((prev, curr) => prev + curr, 0)\n    : values.length;\n\n  return sum / totalWeight;\n}\n\n/**\n * Clamps a number between a minimum and maximum value.\n * @param {number} value - The number to clamp.\n * @param {number} [min=0] - The minimum value to clamp to.\n * @param {number} [max=1] - The maximum value to clamp to.\n * @returns {number} The clamped value, which is between the minimum and maximum values.\n */\nexport function clamp(value: number, min = 0, max = 1): number {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * Splits a string into words, removes duplicates and empty words.\n * @param {string } value - The string to split and trim.\n * @returns {string[]} Returns an array of words, with duplicates and empty strings removed.\n */\nexport function splitAndTrim(value: string): string[] {\n  return value\n    .split(/\\s+/) // split by one or more whitespace characters\n    .filter((word, index, words) => word && words.indexOf(word) === index); // remove empty strings and duplicates\n}\n","import jaroWinkler from \"./algorithms/jaroWinkler\";\nimport { clamp, weightedAverage, splitAndTrim } from \"./utils\";\n\ninterface SearchResult<T> {\n  object: T;\n  similarity: number;\n}\n\ntype KeyWithWeight = { name: string; weight: number };\ntype Keys = Array<KeyWithWeight | string>;\n\nconst BOOST_FACTOR = {\n  CONTAINS_MATCH: 1.2,\n  FIRST_SIMILARITY: 1.1,\n  // this value is less than contains match,\n  // so that if a word starts with the search term, but also contains it,\n  // it will be boosted less than if it only contains it\n  STARTS_WITH: 1.05,\n};\n\n/**\n * Searches for objects in an array based on a search term and a set of keys.\n * @param {T[]} objectsArray - The array of objects to search.\n * @param {string} searchTerm - The search term to match against the objects.\n * @param {Keys} keys - The keys to search in each object.\n * @param {PicoSearchConfig} [config] - Configuration options for the search.\n * @returns {T[]} An array of objects that match the search criteria, ordered by their similarity from the search term.\n */\nexport function picoSearch<T>(\n  objectsArray: T[],\n  searchTerm: string,\n  keys: Keys,\n  config?: { threshold?: number }\n): T[] {\n  const results: SearchResult<T>[] = [];\n\n  const threshold = (config && config.threshold) || 0.8;\n  const trimmedSearchTerm = searchTerm.trim().toLowerCase();\n\n  if (!searchTerm) {\n    return objectsArray;\n  }\n\n  objectsArray.forEach((obj) => {\n    const similarityScores: number[] = [];\n    const weightsInOrder: number[] = [];\n\n    for (const key of keys) {\n      const keyToCheck =\n        typeof key === \"string\" ? key : (key as KeyWithWeight).name;\n\n      if (typeof key !== \"string\") {\n        weightsInOrder.push((key as KeyWithWeight).weight);\n      } else {\n        weightsInOrder.push(1);\n      }\n\n      if (\n        Object.prototype.hasOwnProperty.call(obj, keyToCheck) &&\n        typeof (obj as any)[keyToCheck] === \"string\"\n      ) {\n        const valueToSearch = (obj as any)[keyToCheck].trim().toLowerCase();\n        const similarity = splitWordsAndRank(valueToSearch, trimmedSearchTerm);\n\n        similarityScores.push(similarity);\n      } else {\n        similarityScores.push(0);\n      }\n    }\n\n    const similarityForObject = weightedAverage(\n      similarityScores,\n      weightsInOrder\n    );\n\n    if (similarityForObject >= threshold) {\n      results.push({\n        object: obj,\n        similarity: similarityForObject,\n      });\n    }\n  });\n\n  results.sort((a, b) => b.similarity - a.similarity);\n\n  return results.map((result) => result.object);\n}\n\n/**\n * Splits a string into words, removes duplicates and empty words, and calculates the similarity score for each word.\n * Returns the maximum similarity score, with a boost if the highest matching word shows up first.\n * @param {string} valueToSearch - The string to split into words and rank.\n * @param {string} searchTerm - The search term to match against the words.\n * @returns {number} The maximum similarity score, with a boost if the highest matching word shows up first.\n */\nfunction splitWordsAndRank(valueToSearch: string, searchTerm: string) {\n  const splitSearchCandidate = splitAndTrim(valueToSearch);\n  const splitSearchTerm = splitAndTrim(searchTerm);\n\n  const splitScores = splitSearchTerm.map((searchWord) => {\n    const similarityValues = splitSearchCandidate.map((word) =>\n      getScoreForWord(word, searchWord)\n    );\n\n    const maxSimilarity = Math.max(...similarityValues);\n    const firstSimilarity = similarityValues[0];\n\n    // boost score if the highest matching word shows up first\n    if (maxSimilarity === firstSimilarity) {\n      return maxSimilarity * BOOST_FACTOR.FIRST_SIMILARITY;\n    }\n\n    return clamp(maxSimilarity);\n  });\n\n  return weightedAverage(splitScores);\n}\n\n/**\n * Calculates the similarity score between a word and a search term using the Jaro-Winkler algorithm.\n * If the word includes the search term, the score is boosted by a factor.\n * @param {string} word - The word to compare to the search term.\n * @param {string} searchTerm - The search term to compare to the word.\n * @returns {number} The similarity score between the word and the search term, possibly boosted.\n */\nfunction getScoreForWord(word: string, searchTerm: string) {\n  const jwScore = jaroWinkler(word, searchTerm);\n\n  // if the word includes the search term, boost the score\n  if (word.includes(searchTerm)) {\n    return jwScore * BOOST_FACTOR.CONTAINS_MATCH;\n  }\n\n  return jwScore;\n}\n"],"mappings":"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","names":["jaroWinkler","str1","str2","tempString","len1","len2","delta","flag","ch1Match","matches","i","ch1","j","ch2","transpositions","mCount","jaro","commonPrefix","weightedAverage","values","weights","sum","prev","curr","index","weight","totalWeight","clamp","value","min","max","splitAndTrim","word","words","BOOST_FACTOR","picoSearch","objectsArray","searchTerm","keys","config","results","threshold","trimmedSearchTerm","obj","similarityScores","weightsInOrder","key","keyToCheck","valueToSearch","similarity","splitWordsAndRank","similarityForObject","weightedAverage","a","b","result","splitSearchCandidate","splitAndTrim","splitScores","searchWord","similarityValues","word","getScoreForWord","maxSimilarity","firstSimilarity","clamp","jwScore","jaroWinkler"]}